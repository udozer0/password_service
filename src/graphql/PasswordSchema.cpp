// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "QueryObject.h"
#include "MutationObject.h"

#include "graphqlservice/internal/Schema.h"

#include "graphqlservice/introspection/IntrospectionSchema.h"

#include <algorithm>
#include <array>
#include <functional>
#include <sstream>
#include <stdexcept>
#include <string_view>
#include <utility>
#include <vector>

using namespace std::literals;

namespace graphql {
namespace service {

template <>
password::GeneratePasswordInput Argument<password::GeneratePasswordInput>::convert(const response::Value& value)
{
	auto valueLength = service::ModifiedArgument<int>::require("length", value);
	auto valueUseDigits = service::ModifiedArgument<bool>::require("useDigits", value);
	auto valueUseSymbols = service::ModifiedArgument<bool>::require("useSymbols", value);

	return password::GeneratePasswordInput {
		valueLength,
		valueUseDigits,
		valueUseSymbols
	};
}

} // namespace service

namespace password {

GeneratePasswordInput::GeneratePasswordInput() noexcept
	: length {}
	, useDigits {}
	, useSymbols {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GeneratePasswordInput::GeneratePasswordInput(
		int lengthArg,
		bool useDigitsArg,
		bool useSymbolsArg) noexcept
	: length { std::move(lengthArg) }
	, useDigits { std::move(useDigitsArg) }
	, useSymbols { std::move(useSymbolsArg) }
{
}

GeneratePasswordInput::GeneratePasswordInput(const GeneratePasswordInput& other)
	: length { service::ModifiedArgument<int>::duplicate(other.length) }
	, useDigits { service::ModifiedArgument<bool>::duplicate(other.useDigits) }
	, useSymbols { service::ModifiedArgument<bool>::duplicate(other.useSymbols) }
{
}

GeneratePasswordInput::GeneratePasswordInput(GeneratePasswordInput&& other) noexcept
	: length { std::move(other.length) }
	, useDigits { std::move(other.useDigits) }
	, useSymbols { std::move(other.useSymbols) }
{
}

GeneratePasswordInput::~GeneratePasswordInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

GeneratePasswordInput& GeneratePasswordInput::operator=(const GeneratePasswordInput& other)
{
	GeneratePasswordInput value { other };

	std::swap(*this, value);

	return *this;
}

GeneratePasswordInput& GeneratePasswordInput::operator=(GeneratePasswordInput&& other) noexcept
{
	length = std::move(other.length);
	useDigits = std::move(other.useDigits);
	useSymbols = std::move(other.useSymbols);

	return *this;
}

Operations::Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation)
	: service::Request({
		{ service::strQuery, query },
		{ service::strMutation, mutation }
	}, GetSchema())
	, _query(std::move(query))
	, _mutation(std::move(mutation))
{
}

void AddTypesToSchema(const std::shared_ptr<schema::Schema>& schema)
{
	auto typeGeneratePasswordInput = schema::InputObjectType::Make(R"gql(GeneratePasswordInput)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GeneratePasswordInput)gql"sv, typeGeneratePasswordInput);
	auto typeGeneratedPassword = schema::ObjectType::Make(R"gql(GeneratedPassword)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(GeneratedPassword)gql"sv, typeGeneratedPassword);
	auto typeQuery = schema::ObjectType::Make(R"gql(Query)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Query)gql"sv, typeQuery);
	auto typeMutation = schema::ObjectType::Make(R"gql(Mutation)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Mutation)gql"sv, typeMutation);

	typeGeneratePasswordInput->AddInputValues({
		schema::InputValue::Make(R"gql(length)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Int)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(useDigits)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(useSymbols)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType(R"gql(Boolean)gql"sv)), R"gql()gql"sv)
	});

	AddGeneratedPasswordDetails(typeGeneratedPassword, schema);
	AddQueryDetails(typeQuery, schema);
	AddMutationDetails(typeMutation, schema);

	schema->AddQueryType(typeQuery);
	schema->AddMutationType(typeMutation);
}

std::shared_ptr<schema::Schema> GetSchema()
{
	static std::weak_ptr<schema::Schema> s_wpSchema;
	auto schema = s_wpSchema.lock();

	if (!schema)
	{
		schema = std::make_shared<schema::Schema>(false, R"md()md"sv);
		introspection::AddTypesToSchema(schema);
		AddTypesToSchema(schema);
		s_wpSchema = schema;
	}

	return schema;
}

} // namespace password
} // namespace graphql
